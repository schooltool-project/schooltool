#!/bin/bash
#
# This file is part of the SchoolTool program 
#
# Copyright (c) 2004 Shuttleworth Foundation,
#                    Brian Sutherland
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
#

# This file asks the user questions though debconf. It is normally run at 
# the beginning of an install, so it can depend on almost nothing.

# 

set -e
. /usr/share/debconf/confmodule

#Variables
sourcepackage=schooltool
package=$sourcepackage
sslcert=/etc/$package/$package.privkey.pem
config=/etc/$package/$package.conf

# Setup Debconf
db_capb backup

# Load up parts of the config file we want to change
if [ -f $config ];then
    # Get rid of previous values - config file is cannonical
    db_set $package/listen ""
    db_set $package/web ""
    db_set $package/listen_ssl ""
    db_set $package/web_ssl ""
    # Parse the config file
    exec 4<$config #stdin will mess up debconf!!!
    while read -u 4 x y z;do
        case "$x" in
            listen|listen_ssl|web|web_ssl)
            db_get $package/$x
            if [ -z "$RET" ]; then
                db_set $package/$x "$y"
            else
                db_set $package/$x "$RET $y"
            fi
            ;;
        esac
    done        
fi

# Setup state machine
prevstates=begin
state=listen 

# Utility fuctions
popstate() {
    for i in $prevstates;do
        state=$i
    done
    prevstates=${prevstates%$state}
    prevstates=${prevstates%' '}
}

pushstate () {
    prevstates="$prevstates $1"
}

# State machine to ask ze questions
while [ $state != end ];do
    seen=false
    case $state in

        begin)
        # I don't really know what to do here, should I die with code 30 
        # or force the user to answer the questions.
        exit 30
        ;;

        listen|listen_ssl|web|web_ssl)
        # find out what interfaces the server should listen on
        if db_input medium $package/$state; then
            seen=true
        fi
        if db_go; then
            if $seen;then
                pushstate $state
            fi
            case $state in
                listen) state=web;;
                web) state=listen_ssl;;
                listen_ssl) state=web_ssl;;
                web_ssl) state=create-cert;;
            esac
        else
            popstate
        fi
        ;;

        create-cert)
        # State to decide if we should create/regenerate the certificate
        #Check if an SSL interface is defined
        db_get $package/listen_ssl
        if [ ! -z "$RET" ]; then
            ssl=true
        else
            ssl=false
        fi
        db_get $package/web_ssl
        if [ ! -z "$RET" ]; then
            ssl=true
        fi
        # ask ze question if an SSL interface is defined and cert exists
        if [ -f $sslcert ] && $ssl; then 
            if db_input medium $package/create-cert; then
                seen=true
            fi
        else
            if $ssl; then 
                #no cert, with SSL interface
                db_set $package/create-cert true
            fi
        fi
        if db_go; then # this doesn't return the right exit code sometimes ???
            if $seen;then
                pushstate $state
            fi
            db_get $package/create-cert
            if [ "z$RET" == ztrue ] ;then
                state=cert-type
            else
                state=end
            fi
        else
            popstate
        fi
        ;;

        cert-type)
        # Find out what type of cetificate the user wants
        if db_input low $package/cert-type; then
            seen=true
        fi
        if db_go;then
            if $seen;then
                pushstate $state
            fi
            db_get $package/cert-type
            case "$RET" in
                Create*)
                state=ssl-cert
                ;;
                Import*)
                state=import-cert
                ;;
                *)
                exit 1
                ;;
            esac
        else
            popstate
        fi
        ;;

        import-cert)
        #get the name of the certificate to import
        if db_input high $package/import-cert;then
            seen=true
        fi
        if db_go;then
            db_get $package/import-cert 
            if [ -f "$RET" ];then
                state=end
            else
                state=import-cert
            fi
        else
            popstate
        fi
        ;;

        ssl-cert)
        # Get the certificate info
        # TODO get defaults from certificate if one exists. Be carefull, 
        # openssl may not be available - see man debconf-devel
        templates='countryname statename localityname organisationname ouname hostname email'
        for template in $templates;do
            # steal teplates from make-ssl-cert so I don't have to write/translate them
            db_register make-ssl-cert/$template $package/$template
            db_input high $package/$template || true
        done
        if db_go;then
            state=end
        else
            popstate
        fi
        ;;

        *)
        #uh oh
        echo E: Unknown state
        exit 1 
        ;;
    esac
done
