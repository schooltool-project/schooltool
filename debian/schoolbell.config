#!/bin/bash
#
# This file is part of the SchoolTool program
#
# Copyright (c) 2004 Shuttleworth Foundation,
#                    Brian Sutherland
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
#

# This file asks the user questions though debconf. It is normally run at
# the beginning of an install, so it can depend on almost nothing.

#

set -e
. /usr/share/debconf/confmodule

#Variables
sourcepackage=schoolbell
package=$sourcepackage
sslcert=/etc/$package/$package.privkey.pem
config=/etc/$package/$package.conf

# Setup Debconf
db_capb backup

# Load up parts of the config file we want to change
if [ -f $config ];then
    # Get rid of previous values - config file is cannonical
    db_set $package/rest ""
    db_set $package/web ""
    db_set $package/rest_ssl ""
    db_set $package/web_ssl ""
    # Parse the config file
    exec 4<$config #stdin will mess up debconf!!!
    # XXX - what about ssl_certificate
    while read -u 4 x y z;do
        case "$x" in
            rest|rest_ssl|web|web_ssl)
            db_get $package/$x
            if [ -z "$RET" ]; then
                db_set $package/$x "$y"
            else
                db_set $package/$x "$RET $y"
            fi
            ;;
            ### Compatibility code added in 0.10 to convert listen directives
            ### to rest ones
            listen)
            db_get $package/rest
            if [ -z "$RET" ]; then
                db_set $package/rest "$y"
            else
                db_set $package/rest "$RET $y"
            fi
            ;;
            listen_ssl)
            db_get $package/rest_ssl
            if [ -z "$RET" ]; then
                db_set $package/rest_ssl "$y"
            else
                db_set $package/rest_ssl "$RET $y"
            fi
            ;;
        esac
    done
fi

# Setup state machine
prevstates=begin
state=db

# Utility fuctions
popstate() {
    for i in $prevstates;do
        state=$i
    done
    prevstates=${prevstates%$state}
    prevstates=${prevstates%' '}
}

pushstate () {
    prevstates="$prevstates $1"
}

# State machine to ask ze questions
while [ $state != end ];do
    seen=false
    case $state in

        begin)
        # I don't really know what to do here, should I die with code 30
        # or force the user to answer the questions.
        exit 30
        ;;

        db)
        case "${2}" in
            0.9*1.0rc*) 
            # Don't do anything on upgrades from release candidates
            db_set $package/auto_upgrade_db false
            db_set $package/no_compat_libs "ignore and continue"
            ;;
            
            0.8*|0.9*)
            db_fget $package/auto_upgrade_db seen
            if [ -d /usr/share/schoolbell/schooltool ] ||\
                [ -d /usr/lib/schooltool/schooltool ] ||\
                [ "$RET" == true ];then
                if db_input high $package/auto_upgrade_db; then
                    seen=true
                fi
                db_fset $package/auto_upgrade_db seen true
                db_set $package/no_compat_libs "ignore and continue"
            else
                # Now we are in a situation with database
                # but uninstalled package
                if db_input critical $package/no_compat_libs; then
                    seen=true
                fi
                db_set $package/auto_upgrade_db false
            fi
            ;;

            *)
            # Do nothing
            db_set $package/auto_upgrade_db false
            db_set $package/no_compat_libs "ignore and continue"
            ;;
        esac
        if db_go; then
            if $seen;then
                pushstate $state
            fi
            state=listen
        else
            popstate
        fi
        ;;

        rest|rest_ssl|web|web_ssl)
        # find out what interfaces the server should listen on
        if db_input medium $package/$state; then
            seen=true
        fi
        if db_go; then
            if $seen;then
                pushstate $state
            fi
            case $state in
                rest) state=web;;
                web) state=end;; # XXX SSL certificate generation is disabled
                                # here and in .postinst
                                # until upstream supports it again or decides
                                # not to. In which case it will be removed.
                rest_ssl) state=web_ssl;;
                web_ssl) state=create-cert;;
            esac
        else
            popstate
        fi
        ;;

        create-cert)
        # State to decide if we should create/regenerate the certificate
        #Check if an SSL interface is defined
        db_get $package/rest_ssl
        if [ ! -z "$RET" ]; then
            ssl=true
        else
            ssl=false
        fi
        db_get $package/web_ssl
        if [ ! -z "$RET" ]; then
            ssl=true
        fi
        # ask ze question if an SSL interface is defined and cert exists
        if [ -f $sslcert ] && $ssl; then
            if db_input medium $package/create-cert; then
                seen=true
            fi
        else
            if $ssl; then
                #no cert, with SSL interface
                db_set $package/create-cert true
                db_fset $package/create-cert seen true
            fi
        fi
        if db_go; then # this doesn't return the right exit code sometimes ???
            if $seen;then              # http://issues.schooltool.org/issue122
                pushstate $state
            fi
            db_get $package/create-cert
            if [ "z$RET" == ztrue ] ;then
                state=cert-type
            else
                state=end
            fi
        else
            popstate
        fi
        ;;

        cert-type)
        # Find out what type of cetificate the user wants
        if db_input low $package/cert-type; then
            seen=true
        fi
        if db_go;then
            if $seen;then
                pushstate $state
            fi
            db_get $package/cert-type
            case "$RET" in
                Create*)
                state=ssl-cert
                ;;
                Import*)
                state=import-cert
                ;;
                *)
                exit 1
                ;;
            esac
        else
            popstate
        fi
        ;;

        import-cert)
        #get the name of the certificate to import
        if db_input high $package/import-cert;then
            seen=true
        fi
        if db_go;then
            db_get $package/import-cert
            if [ -f "$RET" ];then
                state=end
            else
                state=import-cert
            fi
        else
            popstate
        fi
        ;;

        ssl-cert)
        # Get the certificate info
        # We should get defaults from certificate if one exists. But we need openssl
        # to read the cerificate and are not gaurenteed that it is installed. Other
        # methods are available, but too hackish.
        #
        # We will use the templates from the ssl-cert packages with only a
        # depends. This means that we have to be carefull because in some cases the
        # templates will not be available (although in normal use cases they will be).
        #
        # The other way is to directly copy the templates at build time or manually,
        # but this is hackish and high maintainence and means our templates will
        # always be out of date with translations.
        #
        # See the thread starting at http://lists.debian.org/debian-devel/2004/10/msg00391.html
        #
        # Basically, for this to work, we have to fail gracefully if the templates
        # are not available or out of date. Then the questions will be asked in the
        # postinst when dependencies are gaurenteed to be fillfulled. Fortunately this
        # is easy, we just don't ask the questions if none are available.
        #
        templates='countryname statename localityname organisationname ouname hostname email'
        for template in $templates;do
            # steal teplates from make-ssl-cert so I don't have to write/translate them
            if db_register make-ssl-cert/$template $package/$template; then
                db_input high $package/$template || true
            fi
        done
        if db_go;then
            state=end
        else
            popstate
        fi
        ;;

        *)
        #uh oh
        echo E: Unknown state
        exit 1
        ;;
    esac
done

db_stop
