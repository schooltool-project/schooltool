===========================
SCHOOLTOOL DEVELOPER MANUAL
===========================

This document describes Schooltool milestone 4.

1. Application Architecture
===========================

Schooltool is a client-server application.  The server and client use
HTTP to communicate and follow the REST architectural style.  The
Relax NG schemas of the XML documents the client and server use to
communicate are in the src/schooltool/schema directory.

There are several clients produced:

   * a GUI client using the wxPython library
   * a scriptable command line client for debugging and functional
     testing
   * an auxiliary client to import initial data from CSV files.


2. Server Architecture
======================

The server was designed for high flexibility and configurability by
introduction of such concepts as facets, relationships, and events.

The overview of these APIs can be found in the schooltool.interfaces
module.

Most important global helper functions (including pseudo-adapters) can
be found in the schooltool.component module.


Application objects
-------------------

There are three kinds of first-class objects (called application
objects) in schooltool: persons, groups, and resources.

Application objects live in application object containers, which serve
as factories and containers for application objects.  When
initializing the application, three application object containers are
created: 'persons', 'groups', and 'resources'.

All people, including pupils, teachers, and administrators, are
organized into a tree of groups.


Paths
-----

All object that need to be traversable through the HTTP interface need
to have a path.  That is, they need to implement the ILocation
interface.  That interface just specifies two attributes: a __name__
and a __parent__.  The parent must also have a path.


Views
-----

All objects accessible over HTTP have auxiliary objects called views,
which take care of publishing objects in XML and parsing the put or
posted XML representations and applying the changes to the objects.

Usually, the view classes take an instance of an object published
(called context) as the first argument of the constructor.

Views are Resources in terms of twisted.web.


Facets
------

The groups and persons can exhibit certain polymorphic behaviour.  For
instance, the same person might be a pupil and later become a teacher.
Or, more commonly, a teacher might periodically become an
administrator.

There might be some data pertinent to a teacher, which is not relevant
when a person is not a teacher.  In order to accomodate these cases,
the concept of a facet is introduced.

A facet is a persistent auxiliary object that is stored in the
__facets__ attribute of an object and implies certain semantics.

The facets are accessed using the schooltool.component.FacetManager
adapter.  The facets must implement the schooltool.interfaces.IFacet
interface.

The facets which are registered to be available for addition to any
application objects through the RESTive API are called Free Floating
Facets.  For example, the schooltool.teaching.TeacherGroupFacet is a
Free Floating Facet, but the facet that the Teacher group adds to all
its members (the schooltool.teaching.TeacherFacet) is not.

Examples:
  schooltool.teaching.TeacherFacet,
  schooltool.absence.AbsenceTrackerFacet


URIs
----

Relationships and roles (and possibly other things in the future) are uniquely
identified by URIs represented in the application as objects providing
schooltool.interfaces.IURIObject.  They are represented in XML data as simple
URIs.  There is a global registry that lets us get a corresponding URI object
(that has a human-friendly name) from a URI string.

Conventionally, the names of URIs have a URI prefix:  URIMembership,
URITeaching, etc.

A set of "standard" URIs is defined in the schooltool.uris module.


Relationships and valencies
---------------------------

There is an infrastructure for persistently storing relationships
between objects.  The relationships are stored in the __links__
attributes of objects, but are accessed using the API defined in
schooltool.interface.

The relationships are implemented as three auxiliary objects:

  +---+    +---------+   +---------------+    +--------+   +---+
  | A |----| Link A  |---| Relationship  |----| Link B |---| B |
  +---+    +---------+   +---------------+    +--------+   +---+

The link objects implement the public schooltool.interfaces.ILink API,
and the Relationship object always remains behind the scenes.

To facilitate the creation of these complex structures, several levels
of helpers are provided.  The relationships are normally created by
invoking a relationship schema, and passing the two related objects as
arguments.  For example::

    from schooltool.membership import Membership
    Membership(group=group1, member=person1)

The relationships are identified by URIs.  Also, both parties in a
relationship have roles, identified by URIs.  In the case of
membership, these are:

    from schooltool.uris import URIMembership, URIMember, URIGroup

Objects that can participate with a certain role in a certain
relationship can express that fact using the hints called valencies.
For example, the schooltool.model.Group objects have a valency to
participate in Membership as groups.  This makes it possibly to post
to the relationships view of a group and create a membership
relationship to another group, person, or resource from it.

Only relationships advertised as valencies can be created via the
RESTive interface.

Events
------

There is an infrastructure for events.

The main idea is that an event is injected where it was originated, is
being resent to related objects according to the event routing tables
on objects, and keeps a list of objects it has visited so it does not
get sent to the same object twice.

Events are non persistent.

The logic of event propagation is shared among the events and the
event targets.  The events need to subclass the EventMixin, and the
event targets need to subclass the EventTargetMixin.  The latter
implements the IEventConfigurable interface.  Event targets need to
provide an event table, which is a sequence of IEventActions.   There
are several EventActions defined that take care of further event
routing, provide a way to call some method, etc.

The application objects subclass the
schooltool.facet.FacetedEventTargetMixin, which generates the event
table of an object by summing up the event tables provided by the
object itself and all of its facets.  This way, the facets can handle
certain kinds of events, or define the behaviour for certain kinds of
events.

All the events dispatched pass the global EventService.  It provides
an API to subscribe to certain kinds of events.

Currently, events are used for logging modifications of relationships
and absence tracking.



3. Domain specific functionality
================================


Attendance tracking
-------------------

All persons can be tracked for attendance.  Usually it is done by
running roll calls on groups.  When some person is not present, an
absence is created on that person.  An absence has several attributes,
such as the "resolved" status (whether an excuse has been presented),
the expected presence date and so on (see
schooltool.interfaces.IAbsence).  The absence contains several
AbsenceComments.  There can be only one unended absence, so if a
person is absent from several consecutive roll calls, several comments
get added to the same Absence object.

When the absence is registered (an AbsenceComment is added to the
Absence), an AbsenceEvent gets sent to the system.  This event
propagates up the membership hierarchy and gets registered in all the
AbsenceTrackers along the way.  Finally, it arrives to the global
AbsenceTrackerUtility, which can be used to track all the absences
happening in the school.

Absence trackers can be added to the groups by sticking on the
free floating AbsenceTrackerFacet.


Timetabling
-----------

Every group or person can have a number of timetables.  First, the
timetables can vary in the timetable schema.  For instance, in a
school with a 4-day rotating timetable there might be some events
recurring weekly.  Second, there are separate timetables for different
time periods, such as semesters.

Every group or person can have a number of own timetables and a number
of composite timetables.  Own timetables consist of the events private
to a group or person, and composite timetables consist of all events
related to a group or person.  For example, a composite timetable for
a teacher will contain all the lessons they are teaching, and a
composite timetable of a pupil will contain all the events from the
private timetables of the groups the're in, in other words -- all the
lessons they need to attend.

The objects having a timetable have to implement ITimetabled.  All of
the application objects are timetabled.

The model used for timetabling is that each set of pupils meeting
regularly with the same teacher for the same subject should be
represented by a separate group.  A group can have at most one
teacher.  So, if the same group of pupils go to Math, English, and
History, there will have to be three separate groups containing the
same pupils.

This model was chosen so the composite timetables for teachers can be
derived by traversing their membership and teaching relationships, and
the composite timetables for groups and pupils can be derived by
traversing their membership relationship.

It should be noted that when an activity using some resources is
posted to a  group's timetable, the same activity gets added to the
resource's timetable.

The timetabling code is located in schooltool.timetable module.  A
Timetable is conceptually a mapping of day ids to TimetableDays.
It also has an attribute day_id with a sequence providing the order of
day ids.

TimetableDay is a mapping between period ids and sets of
TimetableActivities.  Usually those sets contain zero or one
TimetableActivity, but more activities happening at the same time is
also supported by this model.

TimetableActivities are immutable objects just having a title, the
owner, and an ImmutableSet of resources.

So, a Timetable is just a table in which each cell has a day id, a
period id and some activities associated with them.

Now, converting a Timetable to a Calendar involves several auxiliary
objects which keep different parts of the data neeeded for the
process.

SchooldayModel is a calendar for a range of dates which can tell
whether each date within the range is a schoolday or not.  A
SchooldayTemplate is conceptually a mapping between period id and
(start time, duration) of an event.

A TimetableModel puts it all together. It knows the algorithm of
mapping dates to day ids and has a dictionary of days of week to
SchooldayTemplates.  TimetableModel.createCalendar additionally gets
passed a schoolday model and a timetable, and generates a calendar.


Calendaring
-----------

Every application object has two calendars: a private calendar which
can be edited and a read-only calendar formed out of the group's or
person's composite timetable.

The calendar views publish and accept the calendars in the iCalendar
representation (RFC 2445).

When a person books a resource, the same booking event gets added to
the private calendars of that person and the resource.  The owner and
context attributes of the CalendarEvent are in that case,
respectively, the person and the resource.

The core calendaring code is located in the schooltool.cal module.  A
Calendar has a set of CalendarEvents and can be either iterated, or
queried for the events that happened on a certain date.  A calendar
can be merged with another calendar.

